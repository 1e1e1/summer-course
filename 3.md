# 51115139

作業2

## 解題說明

本題要求實作多項式的**相加**、**相減**、**相乘**與**求值**功能，輸入格式為項數、係數與指數，輸出需保持項的輸入順序（特別是加法和減法結果，先輸出第一個多項式的項，再輸出第二個多項式的未合併項）。

## 解題策略

### 類別設計
- **Term**：表示多項式的一項，包含以下欄位：
  - `coef`：係數 (int)。
  - `exp`：指數 (int)。
  - `link`：指向下一項的指針 (Term*)，用於鏈結串列。
- **Polynomial**：表示多項式，使用循環鏈結串列儲存項，包含以下成員：
  - `header`：頭結點，指向循環鏈結串列的起始。
  - `available`：可用結點池，用於記憶體管理。
  - 方法：
    - `allocateTerm()`：分配新項，從可用池或動態分配。
    - `deallocateTerm(Term*)`：回收項到可用池。
    - `operator>>`：輸入多項式，按輸入順序追加項。
    - `operator<<`：輸出多項式，按鏈結串列順序格式化顯示。
    - `operator+`：多項式相加，先複製第一多項式項，再合併或追加第二多項式項。
    - `operator-`：多項式相減，類似加法，第二多項式項係數取負。
    - `operator*`：多項式相乘，按第一多項式項順序生成結果。
    - `Evaluate(float x)`：代入 x 計算多項式值。
    - 建構子、解構子、複製建構子和賦值操作符：管理鏈結串列和記憶體。

### 實現細節
- **輸入**：讀取項數和每項的係數與指數，按輸入順序追加到鏈結串列末尾。
- **加法/減法**：先複製第一多項式 (`p1`) 的項，保持其輸入順序；然後遍歷第二多項式 (`p2`)，合併相同指數的項，或將未合併項追加到結果末尾。
- **乘法**：按第一多項式項順序遍歷，生成乘積項，合併相同指數項，保持相對順序。
- **輸出**：直接遍歷鏈結串列，輸出非零係數項，格式為 `[coef]x^[exp]`，正係數項間加 `+`，負係數項前加 `-`。
- **求值**：遍歷所有項，計算 `coef * pow(x, exp)` 的和。

## 程式實作

以下為程式碼：

```cpp
#include <iostream>
#include <cmath>

class Term {
public:
    int coef;
    int exp;
    Term* link;
};

class Polynomial {
private:
    Term* header;
    Term* available;
    Term* allocateTerm() {
        if (available) {
            Term* temp = available;
            available = available->link;
            return temp;
        }
        return new Term;
    }
    void deallocateTerm(Term* term) {
        term->link = available;
        available = term;
    }
public:
    Polynomial() {
        header = new Term;
        header->link = header;
        available = NULL;
    }
    ~Polynomial() {
        Term* current = header->link;
        while (current != header) {
            Term* temp = current;
            current = current->link;
            deallocateTerm(temp);
        }
        delete header;
    }
    friend std::istream& operator>>(std::istream& is, Polynomial& p) {
        p.~Polynomial();
        p.header = new Term;
        p.header->link = p.header;
        p.available = NULL;
        int n;
        if (!(is >> n)) return is;
        if (n == 0) return is;
        Term* current = p.header;
        for (int i = 0; i < n; ++i) {
            int c, e;
            if (!(is >> c >> e)) {
                std::cerr << "Error: Insufficient data for " << n << " terms." << std::endl;
                return is;
            }
            Term* newTerm = p.allocateTerm();
            newTerm->coef = c;
            newTerm->exp = e;
            newTerm->link = p.header;
            current->link = newTerm;
            current = newTerm;
        }
        return is;
    }
    friend std::ostream& operator<<(std::ostream& os, const Polynomial& p) {
        Term* current = p.header->link;
        bool first = true;
        bool hasTerms = false;
        while (current != p.header) {
            if (current->coef == 0) {
                current = current->link;
                continue;
            }
            hasTerms = true;
            if (!first && current->coef > 0) os << " + ";
            if (current->coef < 0) os << " - ";
            int absCoef = std::abs(current->coef);
            if (absCoef != 1 || current->exp == 0) os << absCoef;
            if (current->exp > 0) os << "x";
            if (current->exp > 1) os << "^" << current->exp;
            first = false;
            current = current->link;
        }
        if (!hasTerms) os << "0";
        return os;
    }
    Polynomial(const Polynomial& a) {
        header = new Term;
        header->link = header;
        available = NULL;
        Term* src = a.header->link;
        Term* dest = header;
        while (src != a.header) {
            Term* newTerm = allocateTerm();
            newTerm->coef = src->coef;
            newTerm->exp = src->exp;
            dest->link = newTerm;
            dest = newTerm;
            src = src->link;
        }
        dest->link = header;
    }
    const Polynomial& operator=(const Polynomial& a) {
        if (this != &a) {
            this->~Polynomial();
            new (this) Polynomial(a);
        }
        return *this;
    }
    Polynomial operator+(const Polynomial& b) const {
        Polynomial result;
        Term* resultTail = result.header;
        Term* aPtr = header->link;
        while (aPtr != header) {
            Term* newTerm = result.allocateTerm();
            newTerm->coef = aPtr->coef;
            newTerm->exp = aPtr->exp;
            newTerm->link = result.header;
            resultTail->link = newTerm;
            resultTail = newTerm;
            aPtr = aPtr->link;
        }
        Term* bPtr = b.header->link;
        while (bPtr != b.header) {
            Term* current = result.header->link;
            Term* prev = result.header;
            bool merged = false;
            while (current != result.header) {
                if (current->exp == bPtr->exp) {
                    current->coef += bPtr->coef;
                    if (current->coef == 0) {
                        prev->link = current->link;
                        result.deallocateTerm(current);
                        current = prev->link;
                    }
                    merged = true;
                    break;
                }
                prev = current;
                current = current->link;
            }
            if (!merged && bPtr->coef != 0) {
                Term* newTerm = result.allocateTerm();
                newTerm->coef = bPtr->coef;
                newTerm->exp = bPtr->exp;
                newTerm->link = result.header;
                resultTail->link = newTerm;
                resultTail = newTerm;
            }
            bPtr = bPtr->link;
        }
        return result;
    }
    Polynomial operator-(const Polynomial& b) const {
        Polynomial result;
        Term* resultTail = result.header;
        Term* aPtr = header->link;
        while (aPtr != header) {
            Term* newTerm = result.allocateTerm();
            newTerm->coef = aPtr->coef;
            newTerm->exp = aPtr->exp;
            newTerm->link = result.header;
            resultTail->link = newTerm;
            resultTail = newTerm;
            aPtr = aPtr->link;
        }
        Term* bPtr = b.header->link;
        while (bPtr != b.header) {
            Term* current = result.header->link;
            Term* prev = result.header;
            bool merged = false;
            while (current != result.header) {
                if (current->exp == bPtr->exp) {
                    current->coef -= bPtr->coef;
                    if (current->coef == 0) {
                        prev->link = current->link;
                        result.deallocateTerm(current);
                        current = prev->link;
                    }
                    merged = true;
                    break;
                }
                prev = current;
                current = current->link;
            }
            if (!merged && bPtr->coef != 0) {
                Term* newTerm = result.allocateTerm();
                newTerm->coef = -bPtr->coef;
                newTerm->exp = bPtr->exp;
                newTerm->link = result.header;
                resultTail->link = newTerm;
                resultTail = newTerm;
            }
            bPtr = bPtr->link;
        }
        return result;
    }
    Polynomial operator*(const Polynomial& b) const {
        Polynomial result;
        Term* aPtr = header->link;
        while (aPtr != header) {
            Term* bPtr = b.header->link;
            while (bPtr != b.header) {
                Term* newTerm = result.allocateTerm();
                newTerm->coef = aPtr->coef * bPtr->coef;
                newTerm->exp = aPtr->exp + bPtr->exp;
                Term* current = result.header;
                Term* next = current->link;
                while (next != result.header) {
                    if (next->exp == newTerm->exp) {
                        next->coef += newTerm->coef;
                        result.deallocateTerm(newTerm);
                        if (next->coef == 0) {
                            current->link = next->link;
                            result.deallocateTerm(next);
                        }
                        newTerm = NULL;
                        break;
                    }
                    current = next;
                    next = next->link;
                }
                if (newTerm && newTerm->coef != 0) {
                    newTerm->link = result.header;
                    current->link = newTerm;
                } else if (newTerm) {
                    result.deallocateTerm(newTerm);
                }
                bPtr = bPtr->link;
            }
            aPtr = aPtr->link;
        }
        return result;
    }
    float Evaluate(float x) const {
        float result = 0;
        Term* current = header->link;
        while (current != header) {
            result += current->coef * pow(x, current->exp);
            current = current->link;
        }
        return result;
    }
};

int main() {
    Polynomial p1, p2;
    std::cin >> p1;
    std::cout << "p1 = " << p1 << std::endl;
    std::cin >> p2;
    std::cout << "p2 = " << p2 << std::endl;
    std::cout << "p1 + p2 = " << p1 + p2 << std::endl;
    std::cout << "p1 - p2 = " << p1 - p2 << std::endl;
    std::cout << "p1 * p2 = " << p1 * p2 << std::endl;
    std::cout << "p1(2.0) = " << p1.Evaluate(2.0) << std::endl;
    return 0;
}
```

## 效能分析
1. 時間複雜度： $O(n)$
2. 空間複雜度： $O(n)$

## 測試與驗證

### 執行案例

| 測試案例 | 輸入多項式 p1 | 輸入多項式 p2 | p1 + p2預計 | p1 + p2實際 |p1 - p2預計 | p1 - p2實際 |p1 * p2預計 | p1 * p2實際 |p1(2.0)預計 | p1(2.0)實際 |
|----------|---------------|---------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|
| 測試一   | 1 2 0 (2) | 1 2 2 (2x^2) | 2 + 2x^2 | 2 + 2x^2 | 2 - 2x^2 | 2 - 2x^2 | 4x^2 | 4x^2 | 2 | 2 |
| 測試二   | 2 3 2 1 1 (3x^2 + x) | 2 2 3 1 0 (2x^3 + 1) | 3x^2 + x + 2x^3 + 1 | 3x^2 + x + 2x^3 + 1 | 3x^2 + x - 2x^3 - 1 | 3x^2 + x - 2x^3 - 1 | 6x^5 + 3x^2 + 2x^4 + x| 6x^5 + 3x^2 + 2x^4 + x| 14 | 14 |



### 結論
本程式成功實作多項式的加法、減法、乘法和求值功能，項按輸入順序儲存和輸出，符合要求。使用循環鏈結串列實現，通過記憶體池管理節省分配開銷。測試案例驗證了程式能正確處理單項和多項多項式，保持 `p1` 項優先的順序，符合數學運算邏輯。

## 申論及開發報告
- **設計理念**：採用物件導向設計，`Term` 類封裝單項式，`Polynomial` 類使用循環鏈結串列管理多項式項，提供直觀的操作符重載。
- **挑戰與解決**：
  - 記憶體管理：使用可用結點池（`available`）避免頻繁的動態分配，確保高效和安全。
- **優勢**：程式結構清晰，支援任意項數的多項式，輸入順序保持一致，易於擴展。
- **改進空間**：乘法結果的項順序可能因合併而略有變化，可進一步定義嚴格順序規則；對於大量項，可考慮優化合併邏輯以降低時間複雜度。
