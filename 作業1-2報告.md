# 51115139

作業1-2

## 解題說明
給定一組字元（例如 "abc"），產生其所有可能的子集合，也就是所謂的 冪集合（powerset）。例如：
```cpp
Input: "abc"
Output: (), (a), (b), (c), (a,b), (a,c), (b,c), (a,b,c)
```
每個元素都可以**選擇要或不要**，因此總共會有 \( 2^n \) 個子集合，其中 \( n \) 為元素個數。

## 程式實作

以下為程式碼：

```cpp
#include <iostream>
#include <string>
using namespace std;

void powerSet(string str, int index = 0, string curr = "") {
    int n = str.length();

    if (index == n) {
        cout << "(";
        for (size_t i = 0; i < curr.length(); ++i) {
            cout << curr[i];
            if (i != curr.length() - 1) cout << ",";
        }
        cout << ")" << endl;
        return;
    }

    powerSet(str, index + 1, curr + str[index]); 
    powerSet(str, index + 1, curr);               
}

int main() {
    string str = "abc";
    powerSet(str);
    return 0;
}

```

## 效能分析

### 時間複雜度：

對於長度為 n 的字串，冪集合總共有$2^n$個子集合，因為每個字元有兩種選擇（選或不選）。

每次呼叫 powerSet 都會遞迴兩次 → $𝑇(𝑛)=2^𝑛$

每次輸出最多長度n→總輸出長度為$𝑂(𝑛⋅2^𝑛)

總時間複雜度： O(n * 2^n)

### 空間複雜度：
遞迴深度最大為$n$

每層呼叫中複製 curr 字串（最長長度n）

總空間複雜度：$𝑂(𝑛^2)$

## 測試與驗證

### 測試案例

執行輸出:
(a,b,c)
(a,b)
(a,c)
(a)
(b,c)
(b)
(c)
()

## 申論及開發報告

### 一、開發目的

這個題目的核心是理解與實作遞迴演算法的應用，特別是將「每個元素兩種選擇」的問題建模成一棵遞迴樹，進而產生所有可能的子集合。
這題常見於程式設計課程與演算法練習，能幫助加強對樹狀結構與複雜度成長的感知。

### 二、實作過程與遇到的問題


| 測試案例 | 輸入 | 預期輸出數量 | 實際輸出數量 |
|----------|------------|---------------------|---------------------|
| 測試一   | ""         | 1                   | 1                   |
| 測試二   | "a"        | 2                   | 2                   |
| 測試三   | "ab"       | 4                   | 4                   |
| 測試四   | "abc"      | 8                   | 8                   |

