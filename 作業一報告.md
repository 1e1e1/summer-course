# 51115139

作業一

## 解題說明
Ackermann 函數是一個知名的數學函數，其特性是高度遞迴且成長非常快速。該函數經常被用來測試編譯器或系統的堆疊管理能力，並驗證遞迴與非遞迴寫法的差異。

Ackermann 函數定義如下：
```cpp
A(0, n) = n + 1
A(m, 0) = A(m - 1, 1)           if m > 0
A(m, n) = A(m - 1, A(m, n - 1)) if m > 0 and n > 0
```
本專案實作兩種版本：
遞迴版本（直接根據定義實作）
非遞迴版本（使用手動堆疊模擬呼叫過程）

## 程式實作

以下為遞迴版本程式碼：

```cpp
#include <iostream>
#include <cstdlib>
using namespace std;

int A(int m,int n){
	while (m!=0) {
		if (n == 0) {
            	m=m-1;
            	n=1;
        	} else {
		n=A(m,n-1);
		m=m-1;
		}
	}
	return n+1;
}

int main() {
    int m, n;
    cout << "請輸入m:";
    cin >> m ;
    cout << "請輸入n:";
    cin >> n;

    int result = A(m, n);
    cout << "A(" << m << ", " << n << ") = " << result << endl;

    return 0;
}
```

以下為非遞迴版本程式碼：

```cpp
#include <iostream>
#include <cstdlib>
using namespace std;

int A(int m, int n) {
    const int MAX_STACK = 10000;
    int stack[MAX_STACK];
    int top = 0;

    stack[top++] = m;

    while (top > 0) {
        m = stack[--top];
        if (m == 0) {
            n = n + 1;
        } else if (n == 0) {
            stack[top++] = m - 1;
            n = 1;
        } else {
            stack[top++] = m - 1;
            stack[top++] = m;    
            n = n - 1;
        }

        if (top >= MAX_STACK) {
            cout << "溢位！" << endl;
            exit(1);
        }
    }

    return n;
}

int main() {
    int m, n;
    cout << "請輸入m: ";
    cin >> m;
    cout << "請輸入n: ";
    cin >> n;

    int result = A(m, n);
    cout << "A(" << m << ", " << n << ") = " << result << endl;

    return 0;
}
```

## 效能分析
以下為遞迴版本效能分析：
1. 時間複雜度：超指數成長 $O(A(m, n))$。
2. 空間複雜度：最大堆疊深度為 $O(A(m, n))$。

以下為非遞迴版本效能分析：
1. 時間複雜度：超指數成長 $O(A(m, n))$。
2. 空間複雜度：空間複雜度為 $O(100 × log n + π)$。

## 測試與驗證

### 測試案例
遞迴版本測試案例：
| 測試案例 | 輸入參數 $m$ &n$ | 預期輸出 | 實際輸出 |
|----------|-----------------|----------|----------|
| 測試一   | $m = 1$ $n = 2$ | 4        | 4        |
| 測試二   | $m = 2$ $n = 3$ | 9        | 9        |
| 測試三   | $m = 3$ $n = 2$ | 29       | 29       |
| 測試四   | $m = 4$ $n = 1$ | 65533    | 無(堆疊溢位)|
| 測試五   | $m = 1$ $n = 4$ | 6        | 6        |

非遞迴版本測試案例：
| 測試案例 | 輸入參數 $m$ &n$ | 預期輸出 | 實際輸出 |
|----------|-----------------|----------|----------|
| 測試一   | $m = 1$ $n = 2$ | 4        | 4        |
| 測試二   | $m = 2$ $n = 3$ | 9        | 9        |
| 測試三   | $m = 3$ $n = 2$ | 29       | 29       |
| 測試四   | $m = 4$ $n = 1$ | 65533    | 堆疊溢位！|
| 測試五   | $m = 1$ $n = 4$ | 6        | 6        |

### 結論

1. 程式能正確計算 Ackermann 函數在小型輸入值（例如 $m \leq 3$）的輸出結果，遞迴與非遞迴版本皆符合預期。
2. 當 $m = 4$ 時，由於 Ackermann 函數成長極快，無論遞迴或非遞迴版本都會出現「堆疊溢位」，顯示出該函數對系統資源的消耗非常敏感。
3. 測試案例涵蓋了典型輸入（$m=1,2,3$）與極端邊界值（$m=4$），能有效驗證程式的正確性與效能極限。

## 申論及開發報告

### 一、開發目的

老師課堂上介紹 Ackermann 函數是一個成長速度非常快的遞迴例子，為了更了解遞迴的運作與限制，我實作了兩種版本：

- 遞迴版本
- 非遞迴（用陣列模擬堆疊）版本

希望藉由比較兩者差異，加深對遞迴與堆疊結構的理解。

### 二、實作過程與遇到的問題

遞迴版本:
- 寫法簡單，直接對應數學公式。
- 缺點是 m 或 n 稍大時就會造成 Stack Overflow，像是 A(4,1) 就跑不動。

非遞迴版本:
- 用 int 陣列模擬呼叫堆疊。
- 難點在處理遞迴的重複呼叫與回傳值。
- 雖然程式碼較複雜，但能處理較大的輸入。

### 三、效能與差異比較

| 項目       | 遞迴版本        | 非遞迴版本       |
|------------|----------------|------------------|
| 時間效率   | 慢              | 慢              |
| 空間使用   | 系統堆疊         | 自行分配堆疊空間 |
| 穩定性     | 易當機           | 較穩定           |

## 四、學習心得

這次作業讓我更了解：

- 遞迴背後就是堆疊的操作。
- 系統資源有限，寫程式要考慮邊界條件。
- 自己模擬遞迴可以更彈性地控制行為，也比較不容易當機。
