# 51115139

作業2
## 解題說明

本題要實作多項式的 **相加**、**相乘** 與 **求值** 三項功能。


## 解題策略

### 類別設計
Term:表示一個項目
欄位：
- coef: 係數 (float)
- exp: 指數 (int)
###Polynomial
儲存多項式的項目
使用 Term* termArray 動態陣列
方法：
 - newTerm(float coef, int exp)：新增項目，自動擴充
 - operator+：多項式相加
 - operator*：多項式相乘
 - Eval(float x)：代入 x 計算值
 - operator>>：輸入（項數，係數與指數）
 - operator<<：輸出格式化字串
## 程式實作

以下為程式碼：

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

typedef struct {
    float coef;
    int exp;
} Term;

typedef struct {
    Term* termArray;
    int capacity;
    int terms;
} Polynomial;

// 建立 Polynomial
Polynomial Polynomial_create(int initialCapacity) {
    if (initialCapacity <= 0) {
        fprintf(stderr, "Invalid capacity!\n");
        exit(1);
    }

    Polynomial p;
    p.capacity = initialCapacity;
    p.terms = 0;
    p.termArray = (Term*)malloc(sizeof(Term) * initialCapacity);
    return p;
}

// 解構 Polynomial
void Polynomial_destroy(Polynomial* p) {
    free(p->termArray);
    p->termArray = NULL;
    p->capacity = 0;
    p->terms = 0;
}

// 複製 Polynomial
void Polynomial_copy(Polynomial* dest, const Polynomial* src) {
    dest->capacity = src->capacity;
    dest->terms = src->terms;
    dest->termArray = (Term*)malloc(sizeof(Term) * src->capacity);
    memcpy(dest->termArray, src->termArray, sizeof(Term) * src->terms);
}

// 新增一項
void Polynomial_newTerm(Polynomial* p, float coef, int exp) {
    if (coef == 0) return;
    if (p->terms >= p->capacity) {
        p->capacity *= 2;
        Term* newArray = (Term*)malloc(sizeof(Term) * p->capacity);
        memcpy(newArray, p->termArray, sizeof(Term) * p->terms);
        free(p->termArray);
        p->termArray = newArray;
    }
    p->termArray[p->terms].coef = coef;
    p->termArray[p->terms].exp = exp;
    p->terms++;
}

// 多項式加法
Polynomial Polynomial_add(const Polynomial* a, const Polynomial* b) {
    Polynomial result = Polynomial_create(4);
    int i = 0, j = 0;

    while (i < a->terms && j < b->terms) {
        if (a->termArray[i].exp == b->termArray[j].exp) {
            float sum = a->termArray[i].coef + b->termArray[j].coef;
            if (sum != 0)
                Polynomial_newTerm(&result, sum, a->termArray[i].exp);
            i++; j++;
        } else if (a->termArray[i].exp > b->termArray[j].exp) {
            Polynomial_newTerm(&result, a->termArray[i].coef, a->termArray[i].exp);
            i++;
        } else {
            Polynomial_newTerm(&result, b->termArray[j].coef, b->termArray[j].exp);
            j++;
        }
    }

    while (i < a->terms) Polynomial_newTerm(&result, a->termArray[i].coef, a->termArray[i++].exp);
    while (j < b->terms) Polynomial_newTerm(&result, b->termArray[j].coef, b->termArray[j++].exp);

    return result;
}

// 多項式乘法
Polynomial Polynomial_multiply(const Polynomial* a, const Polynomial* b) {
    Polynomial result = Polynomial_create(4);

    for (int i = 0; i < a->terms; ++i) {
        for (int j = 0; j < b->terms; ++j) {
            float prodCoef = a->termArray[i].coef * b->termArray[j].coef;
            int prodExp = a->termArray[i].exp + b->termArray[j].exp;

            if (prodCoef != 0) {
                int found = 0;
                for (int k = 0; k < result.terms; ++k) {
                    if (result.termArray[k].exp == prodExp) {
                        result.termArray[k].coef += prodCoef;
                        found = 1;
                        break;
                    }
                }
                if (!found) Polynomial_newTerm(&result, prodCoef, prodExp);
            }
        }
    }

    return result;
}

// 多項式求值
float Polynomial_eval(const Polynomial* p, float x) {
    float result = 0;
    for (int i = 0; i < p->terms; ++i) {
        result += p->termArray[i].coef * powf(x, p->termArray[i].exp);
    }
    return result;
}

// 輸入多項式
void Polynomial_input(Polynomial* p) {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        float coef;
        int exp;
        scanf("%f%d", &coef, &exp);
        Polynomial_newTerm(p, coef, exp);
    }
}

// 輸出多項式
void Polynomial_print(const Polynomial* p) {
    for (int i = 0; i < p->terms; ++i) {
        if (i > 0) printf(" + ");
        printf("%.2fx^%d", p->termArray[i].coef, p->termArray[i].exp);
    }
    printf("\n");
}

// 主程式
int main() {
    Polynomial A = Polynomial_create(4);
    Polynomial B = Polynomial_create(4);

    printf("Polynomial A=");
    Polynomial_input(&A);
    printf("Polynomial B=");
    Polynomial_input(&B);

    Polynomial sum = Polynomial_add(&A, &B);
    Polynomial prod = Polynomial_multiply(&A, &B);

    printf("A + B = ");
    Polynomial_print(&sum);
    printf("A * B = ");
    Polynomial_print(&prod);

    float x;
    printf("x=");
    scanf("%f", &x);

    printf("A(%.2f) = %.2f\n", x, Polynomial_eval(&A, x));
    printf("B(%.2f) = %.2f\n", x, Polynomial_eval(&B, x));
    printf("A + B(%.2f) = %.2f\n", x, Polynomial_eval(&sum, x));
    printf("A * B(%.2f) = %.2f\n", x, Polynomial_eval(&prod, x));

    return 0;
}

```


## 效能分析

|操作|時間複雜度|空間複雜度|分析|
|------|------|------|------|
|newTerm()|O(1)  |O(n)|每次擴容容量翻倍 *=2|
|operator+|O(n+m)|O(n+m)|兩個已排序陣列合併|
|operator*|O(n*m)|O(n+m)|需要雙層迴圈遍歷所有項目並合併|
|eval     |O(n)  |O(1)|只需遍歷一次|

## 測試與驗證

### 執行案例


| 測試案例 | 輸入多項式$A$ | 輸入多項式$B$  | A + B輸出  | A * B輸出 | 輸入x的值| A(x)|B(x) | A + B (x)|A * B (x)|
| -------- | -----------  | --------| ---------- | ------------- |----|-----|----|----|----|
| 測試一   |3 2 2 3 1 2 1|2 3 1 2 1| 2.00x^2 + 6.00x^1 + 4.00x^1 |10.00x^3 + 25.00x^2|2| A(2.00) = 18.00|B(2.00) = 10.00| A + B(2.00) = 28.00|A * B(2.00) = 180.00|
| 測試二   |2 3 4 1 1|2 4 2 1 0| 3.00x^4 + 4.00x^2 + 1.00x^1 + 50662716.00x^0|12.00x^6 + 3.00x^4 + 4.00x^3 + 1.00x^1|3| A(3.00) = 246.00|B(3.00) = 37.00|A + B(3.00) = 50663000.00|A * B(3.00) = 9102.00|

### 結論
本專案成功實作了多項式的基本運算功能，包括加法（+）、乘法（*）與指定變數的代入求值（Eval(x)）。透過類別封裝的方式，實現了結構清晰、可擴充性高的程式架構。經過多組測試，程式能正確處理多項式項數不同、指數重複、代入實數等狀況，符合數學定義與計算邏輯。

## 申論及開發報告
為了模擬數學中多項式的結構與運算，採用了物件導向的設計方式：

Term 類別：封裝單項式的係數與指數。

Polynomial 類別：用動態陣列儲存多項式，並提供必要的運算方法與操作符重載。


